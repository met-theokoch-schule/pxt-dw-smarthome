<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="-[Yt)Xl$jPgBQl0HN3tL" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="G!DoV;C{tYldKADh?DVc"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum TouchSensor {" line1="    S0 = 0b000000000001," line2="    S1 = 0b000000000010," line3="    S2 = 0b000000000100," line4="    S3 = 0b000000001000," line5="    S4 = 0b000000010000," line6="    S5 = 0b000000100000," line7="    S6 = 0b000001000000," line8="    S7 = 0b000010000000," line9="    S8 = 0b000100000000," line10="    S9 = 0b001000000000," line11="    // T10 = 0b010000000000, //not used" line12="    // T11 = 0b100000000000. //not used" line13="}" numlines="14"></mutation><next><block type="typescript_statement" id="5l=Z=a5/kg^Z-Ycln@)["><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum onoff {" line1="    //% block=&quot;an&quot;" line2="    on = 1," line3="    //% block=&quot;aus&quot;" line4="    off = 2," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="96NQ~UkPKgAKng_(*`1X"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum openclose {" line1="    //% block=&quot;öffnen&quot;" line2="    open = 1," line3="    //% block=&quot;schließen&quot;" line4="    close = 2," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="P,S9VXkT3+vFMa$]$tWl"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum lampennamen {" line1="    //% block=&quot;Deckenlampe 1&quot;" line2="    dl1 = 1," line3="    //% block=&quot;Deckenlampe 2&quot;" line4="    dl2 = 0," line5="    //% block=&quot;Außenlampe&quot;" line6="    al = 2," line7="    //% block=&quot;Wandlampe&quot;" line8="    wl = 3" line9="}" numlines="10"></mutation><next><block type="typescript_statement" id="@`*[ybV,zdIygp)gXjoj"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace smarthome {" line1="" line2="    /**" line3="     * Code für den Rolladen" line4="     * by Moritz Metelmann" line5="     */" line6="" line7="    let shades_open: boolean = true;" line8="" line9="    /**" line10="    * Öffnet/Schließt den Rolladen" line11="    */" line12="    //% block=&quot;$state shades&quot;" line13="    //% block.loc.de=&quot;Rolladen $state&quot;" line14="    //% inlineInputMode=inline" line15="    export function SwitchShades(state: openclose = openclose.open) {" line16="        if (state === openclose.open) {" line17="            pins.servoWritePin(AnalogPin.C16, 0)" line18="            basic.pause(800)" line19="            pins.servoSetPulse(AnalogPin.C16, 0)" line20="            shades_open = true;" line21="        } else {" line22="            pins.servoWritePin(AnalogPin.C16, 180)" line23="            basic.pause(800)" line24="            pins.servoSetPulse(AnalogPin.C16, 0)" line25="            shades_open = false;" line26="        }" line27="    }" line28="" line29="    /**" line30="    * Ist der Rolladen offen?" line31="    */" line32="    //% block=&quot;shade is open&quot;" line33="    //% block.loc.de=&quot;Rolladen ist offen&quot;" line34="    //% weight=5" line35="    //% group=&quot;Zustände&quot;" line36="    export function GetShadesStatus(): boolean {" line37="        return shades_open;" line38="    }" line39="" line40="    /**" line41="     * Code für die Klimaanlage" line42="     * by Moritz Metelmann" line43="     */" line44="" line45="    let ac_on: boolean = false;" line46="" line47="    /**" line48="    * Schaltet die Klimaanlage an/aus" line49="    */" line50="    //% block=&quot;switch aircondition $state&quot;" line51="    //% block.loc.de=&quot;schalte die Klimaanlage $state&quot;" line52="    //% inlineInputMode=inline" line53="    //% weight=5" line54="    export function SwitchAC(state: onoff = onoff.on) {" line55="        if (state === onoff.on) {" line56="            motors.dualMotorPower(Motor.M0, 100)" line57="            ac_on = true;" line58="        } else {" line59="            motors.dualMotorPower(Motor.M0, 0)" line60="            ac_on = false;" line61="        }" line62="    }" line63="" line64="    /**" line65="    * Schaltet die Klimaanlage auf eine prozentuale Geschwindikteit" line66="    */" line67="    //% blockId=CalliBrightness block=&quot;set aircondition to %c %&quot;" line68="    //% block.loc.de=&quot;setze Klimaanlage auf %c %&quot;" line69="    //% c.defl=80" line70="    //% c.min=25 c.max=100" line71="    export function DimAC(c: number) {" line72="        if (c &lt; 25) {" line73="            c = 25" line74="        }" line75="        if (c &gt; 100) {" line76="            c = 100" line77="        }" line78="        motors.dualMotorPower(Motor.M0, c)" line79="        ac_on = true;" line80="    }" line81="" line82="    /**" line83="    * Ist die Klimaanlage an?" line84="    */" line85="    //% block=&quot;aircondition is on&quot;" line86="    //% block.loc.de=&quot;Klimaanlage ist an&quot;" line87="    //% weight=5" line88="    //% group=&quot;Zustände&quot;" line89="    export function GetACStatus(): boolean {" line90="        return ac_on;" line91="    }" line92="" line93="    /**" line94="     * Code für NeoPixel LED's (Lampen)" line95="     * based on https://github.com/MKleinSB/pxt-callicolor/blob/master/callicolor.ts" line96="     * by Michael Klein which took parts from" line97="     * https://github.com/BrightWearables/pxt-microbit-brightboard" line98="     */" line99="" line100="    let Lampen = neopixel.create(DigitalPin.C8, 11, NeoPixelMode.RGB)" line101="    let dl2 = Lampen.range(0, 0);" line102="    let dl1 = Lampen.range(1, 1);" line103="    let al = Lampen.range(2, 2);" line104="    let wl = Lampen.range(3, 10);" line105="" line106="    let lampen_state = [false, false, false, false];" line107="" line108="    let ccolors = [0xff0000, 0xFF7F00, 0xFFFE00, 0x7FFF00, 0x00FF00, 0x00FF7F," line109="        0x00FFFE, 0x0040FF, 0x0000FF, 0x6000FF, 0xFE00FF, 0xFF0040]" line110="" line111="    //% block=&quot;set wall light to $color1 $color2 $color3 $color4 $color5 $color6 $color7 $color8&quot;" line112="    //% block.loc.de=&quot;setze Wandlampe auf $color1 $color2 $color3 $color4 $color5 $color6 $color7 $color8&quot;       " line113="    //% color1.shadow=&quot;LampenColorNumberPicker&quot;  color1.defl=0xff0000" line114="    //% color2.shadow=&quot;LampenColorNumberPicker&quot;  color2.defl=0xff8000" line115="    //% color3.shadow=&quot;LampenColorNumberPicker&quot;  color3.defl=0xffff00" line116="    //% color4.shadow=&quot;LampenColorNumberPicker&quot;  color4.defl=0x00ff00" line117="    //% color5.shadow=&quot;LampenColorNumberPicker&quot;  color5.defl=0x00ffff" line118="    //% color6.shadow=&quot;LampenColorNumberPicker&quot;  color6.defl=0x0000ff" line119="    //% color7.shadow=&quot;LampenColorNumberPicker&quot;  color7.defl=0xff00ff" line120="    //% color8.shadow=&quot;LampenColorNumberPicker&quot;  color8.defl=0xff0080" line121="    //% inlineInputMode=inline" line122="    export function ShowWallLampColorPixel(color1: number, color2: number, color3: number, color4: number, color5: number, color6: number, color7: number, color8: number) {" line123="        Lampen.setBrightness(20);" line124="        Lampen.setPixelColor(3, color1)" line125="        Lampen.setPixelColor(4, color2)" line126="        Lampen.setPixelColor(5, color3)" line127="        Lampen.setPixelColor(6, color4)" line128="        Lampen.setPixelColor(7, color5)" line129="        Lampen.setPixelColor(8, color6)" line130="        Lampen.setPixelColor(9, color7)" line131="        Lampen.setPixelColor(10, color8)" line132="        Lampen.show()" line133="        Lampen.setBrightness(255);" line134="        if (color1 != 0x000000 || color2 != 0x000000 || color3 != 0x000000 || color4 != 0x000000 || color5 != 0x000000 || color6 != 0x000000 || color7 != 0x000000 || color8 != 0x000000) {" line135="            lampen_state[3] = true;" line136="        } else {" line137="            lampen_state[3] = false;" line138="        }" line139="    }" line140="" line141="    /**" line142="    * Schalte eine Lampe in einer Farbe" line143="    */" line144="    //% block=&quot;set $lampe to $color&quot;" line145="    //% block.loc.de=&quot;setze $lampe auf $color&quot;" line146="    //% color.shadow=&quot;LampenColorNumberPicker&quot; color.defl='#ffffff'" line147="    //% inlineInputMode=inline" line148="    export function ShowLampColor(lampe: lampennamen = lampennamen.dl1, color: number) {" line149="        if (lampe &lt; 3) {" line150="            Lampen.setPixelColor(lampe, color)" line151="            if (color != 0x000000) {" line152="                lampen_state[lampe] = true;" line153="            } else {" line154="                lampen_state[lampe] = false;" line155="            }" line156="        } else { // Wandlampe" line157="            wl.setBrightness(20)" line158="            wl.showColor(color)" line159="            if (color != 0x000000) {" line160="                lampen_state[3] = true;" line161="            } else {" line162="                lampen_state[3] = false;" line163="            }" line164="        }" line165="        Lampen.show()" line166="        wl.setBrightness(255)" line167="    }" line168="" line169="    /**" line170="    * Schalte eine Lampe aus" line171="    */" line172="    //% block=&quot;switch $lampe off&quot;" line173="    //% block.loc.de=&quot;schalte $lampe aus&quot;" line174="    //% inlineInputMode=inline" line175="    export function SwitchLampOff(lampe: lampennamen = lampennamen.dl1) {" line176="        if (lampe &lt; 3) {" line177="            Lampen.setPixelColor(lampe, 0x000000)" line178="        } else { // Wandlampe" line179="            wl.showColor(0x000000)" line180="        }" line181="        lampen_state[lampe] = false;" line182="        Lampen.show()" line183="    }" line184="" line185="    /**" line186="    * Gibt den Status einer Lampe zurück" line187="    */" line188="    //% block=&quot;$lampe is on&quot;" line189="    //% block.loc.de=&quot;$lampe ist an&quot;" line190="    //% inlineInputMode=inline" line191="    //% weight=5" line192="    //% group=&quot;Zustände&quot;" line193="    export function GetLampStatus(lampe: lampennamen = lampennamen.dl1): boolean {" line194="        return lampen_state[lampe];" line195="    }" line196="" line197="    /**" line198="    * Custom color picker" line199="    */" line200="    //% blockId=LampenColorNumberPicker block=&quot;%value&quot;" line201="    //% blockHidden=true" line202="    //% shim=TD_ID" line203="    //% value.fieldEditor=&quot;colornumber&quot; value.fieldOptions.decompileLiterals=true" line204="    //% weight=150" line205="    //% value.fieldOptions.colours='[&quot;#ff0000&quot;,&quot;#ff8000&quot;,&quot;#ffff00&quot;,&quot;#00ff00&quot;,&quot;#00ffff&quot;,&quot;#0000ff&quot;,&quot;#ff00ff&quot;,&quot;#ff0080&quot;,&quot;#ffffff&quot;,&quot;#909090&quot;,&quot;#505050&quot;,&quot;#000000&quot;]'" line206="    //% value.fieldOptions.columns=4 value.fieldOptions.className='rgbColorPicker'  " line207="    export function LampenColorNumberPicker(value: number) {" line208="        return value;" line209="    }" line210="" line211="    /**" line212="     * Code für die Touch Schalter" line213="     * based on https://github.com/mkleinsb/pxt-mpr121 by Michael Klein" line214="     * mpr 121 touch blocks based on touch.ts 0.17.5" line215="     * Auf Basis von https://github.com/1010Technologies/pxt-makerbit" line216="     * Copyright (c) 2018 Roger Wagner, Philipp Henkel &amp; Michael Klein" line217="     * MIT License" line218="     */" line219="" line220="    const MPR121_ADDRESS = 0x5A" line221="    const TOUCH_STATUS_PAUSE_BETWEEN_READ = 50" line222="" line223="    interface TouchController {" line224="        lastTouchStatus: number" line225="        lastEventValue: number" line226="    }" line227="" line228="    let touchController: TouchController" line229="" line230="    const MPR121_TOUCH_SENSOR_TOUCHED_ID = 2148" line231="    const MPR121_TOUCH_SENSOR_RELEASED_ID = 2149" line232="" line233="" line234="    /**" line235="     * Initialize the touch controller." line236="     */" line237="" line238="    //% blockId=&quot;mpr121_touch_init&quot; block=&quot;initialisiere touch-Sensor&quot;" line239="    //% weight=70" line240="    function initTouchController(): void {" line241="" line242="        if (!!touchController) {" line243="            return" line244="        }" line245="" line246="        touchController = {" line247="            lastTouchStatus: 0," line248="            lastEventValue: 0," line249="        }" line250="" line251="        const addr = MPR121_ADDRESS" line252="        mpr121.reset(addr)" line253="" line254="        // Stop capture" line255="        mpr121.stop(addr)" line256="" line257="        // Input filter for rising state" line258="        mpr121.configure(addr, mpr121.Config.MHDR, 0x01)" line259="        mpr121.configure(addr, mpr121.Config.NHDR, 0x01)" line260="        mpr121.configure(addr, mpr121.Config.NCLR, 0x10)" line261="        mpr121.configure(addr, mpr121.Config.FDLR, 0x20)" line262="" line263="        // Input filter for falling state" line264="        mpr121.configure(addr, mpr121.Config.MHDF, 0x01)" line265="        mpr121.configure(addr, mpr121.Config.NHDF, 0x01)" line266="        mpr121.configure(addr, mpr121.Config.NCLF, 0x10)" line267="        mpr121.configure(addr, mpr121.Config.FDLF, 0x20)" line268="" line269="        // Input filter for touched state" line270="        mpr121.configure(addr, mpr121.Config.NHDT, 0x01)" line271="        mpr121.configure(addr, mpr121.Config.NCLT, 0x10)" line272="        mpr121.configure(addr, mpr121.Config.FDLT, 0xFF)" line273="" line274="        // Unused proximity sensor filter" line275="        mpr121.configure(addr, mpr121.Config.MHDPROXR, 0x0F)" line276="        mpr121.configure(addr, mpr121.Config.NHDPROXR, 0x0F)" line277="        mpr121.configure(addr, mpr121.Config.NCLPROXR, 0x00)" line278="        mpr121.configure(addr, mpr121.Config.FDLPROXR, 0x00)" line279="        mpr121.configure(addr, mpr121.Config.MHDPROXF, 0x01)" line280="        mpr121.configure(addr, mpr121.Config.NHDPROXF, 0x01)" line281="        mpr121.configure(addr, mpr121.Config.NCLPROXF, 0xFF)" line282="        mpr121.configure(addr, mpr121.Config.FDLPROXF, 0xFF)" line283="        mpr121.configure(addr, mpr121.Config.NHDPROXT, 0x00)" line284="        mpr121.configure(addr, mpr121.Config.NCLPROXT, 0x00)" line285="        mpr121.configure(addr, mpr121.Config.FDLPROXT, 0x00)" line286="" line287="        // Debounce configuration (used primarily for interrupts)" line288="        mpr121.configure(addr, mpr121.Config.DTR, 0x11)" line289="" line290="        // Electrode clock frequency etc" line291="        mpr121.configure(addr, mpr121.Config.AFE1, 0xFF)" line292="        mpr121.configure(addr, mpr121.Config.AFE2, 0x30)" line293="" line294="        // Enable autoconfiguration / calibration" line295="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_0, 0x00)" line296="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_1, 0x00)" line297="" line298="        // Tuning parameters for the autocalibration algorithm" line299="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_USL, 0x00)" line300="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_LSL, 0x00)" line301="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_TL, 0x00)" line302="" line303="        // Default sensitivity thresholds" line304="        mpr121.configureThresholds(addr, 60, 20)" line305="" line306="        // Restart capture" line307="        mpr121.start(" line308="            addr," line309="            mpr121.CalibrationLock.BaselineTrackingAndInitialize," line310="            mpr121.Proximity.DISABLED," line311="            mpr121.Touch.ELE_0_TO_11" line312="        )" line313="        control.inBackground(detectAndNotifyTouchEvents)" line314="    }" line315="" line316="    function detectAndNotifyTouchEvents() {" line317="        let previousTouchStatus = 0" line318="" line319="        while (true) {" line320="            const touchStatus = mpr121.readTouchStatus(MPR121_ADDRESS)" line321="            touchController.lastTouchStatus = touchStatus" line322="" line323="            for (let touchSensorBit = 1; touchSensorBit &lt;= 2048; touchSensorBit &lt;&lt;= 1) {" line324="" line325="                // Raise event when touch starts" line326="                if ((touchSensorBit &amp; touchStatus) !== 0) {" line327="                    if (!((touchSensorBit &amp; previousTouchStatus) !== 0)) {" line328="                        control.raiseEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, touchSensorBit)" line329="                        touchController.lastEventValue = touchSensorBit" line330="                    }" line331="                }" line332="" line333="                // Raise event when touch ends" line334="                if ((touchSensorBit &amp; touchStatus) === 0) {" line335="                    if (!((touchSensorBit &amp; previousTouchStatus) === 0)) {" line336="                        control.raiseEvent(MPR121_TOUCH_SENSOR_RELEASED_ID, touchSensorBit)" line337="                        touchController.lastEventValue = touchSensorBit" line338="                    }" line339="                }" line340="            }" line341="" line342="            previousTouchStatus = touchStatus" line343="" line344="            basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line345="        }" line346="    }" line347="" line348="    /**" line349="     * Mache etwas, wenn ein spezieller Sensor berührt wird." line350="     * Dieses Touch-Ereignis wird direkt zu Beginn der Berührung ausgeführt." line351="     * @param sensor der Touchsensor der überwacht werden soll, z.B.: TouchSensor.T0" line352="     * @param handler body code der bei der Berührung des Sensors ausgeführt werden soll" line353="    */" line354="" line355="    //% blockId=mpr121_touch_on_touch_sensor_down" line356="    //% block=&quot;wenn Schalter | %sensor | gedrückt&quot;" line357="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=3" line358="    //% sensor.fieldOptions.tooltips=&quot;false&quot;" line359="    //% weight=65" line360="    export function onTouchSensorTouched(sensor: TouchSensor, handler: () =&gt; void) {" line361="        initTouchController()" line362="        control.onEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, sensor, () =&gt; {" line363="            setupContextAndNotify(handler)" line364="        })" line365="    }" line366="" line367="    function setupContextAndNotify(handler: () =&gt; void) {" line368="        touchController.lastEventValue = control.eventValue()" line369="        handler()" line370="    }" line371="" line372="    // Communication module for MPR121 capacitive touch sensor controller" line373="    // https://www.sparkfun.com/datasheets/Components/MPR121.pdf" line374="    export namespace mpr121 {" line375="" line376="        export enum CalibrationLock {" line377="            BaselineTrackingOn = 0b00," line378="            BaselineTrackingOff = 0b01," line379="            BaselineTrackingAndInitializeFirst5MSB = 0b10," line380="            BaselineTrackingAndInitialize = 0b11" line381="        }" line382="" line383="        export enum Proximity {" line384="            DISABLED = 0b00," line385="            ELE0_TO_1 = 0b01," line386="            ELE_0_TO_3 = 0b10," line387="            ELE_0_TO_11 = 0b11" line388="        }" line389="" line390="        export enum Touch {" line391="            DISABLED = 0b0000," line392="            ELE_0 = 0b0001," line393="            ELE_0_TO_1 = 0b0010," line394="            ELE_0_TO_2 = 0b0011," line395="            ELE_0_TO_3 = 0b0100," line396="            ELE_0_TO_4 = 0b0101," line397="            ELE_0_TO_5 = 0b0110," line398="            ELE_0_TO_6 = 0b0111," line399="            ELE_0_TO_7 = 0b1000," line400="            ELE_0_TO_8 = 0b1001," line401="            ELE_0_TO_9 = 0b1010," line402="            ELE_0_TO_10 = 0b1011," line403="            ELE_0_TO_11 = 0b1100" line404="        }" line405="" line406="        export enum Config {" line407="            MHDR = 0x2B," line408="            NHDR = 0x2C," line409="            NCLR = 0x2D," line410="            FDLR = 0x2E," line411="            MHDF = 0x2F," line412="            NHDF = 0x30," line413="            NCLF = 0x31," line414="            FDLF = 0x32," line415="            NHDT = 0x33," line416="            NCLT = 0x34," line417="            FDLT = 0x35," line418="            MHDPROXR = 0x36," line419="            NHDPROXR = 0x37," line420="            NCLPROXR = 0x38," line421="            FDLPROXR = 0x39," line422="            MHDPROXF = 0x3A," line423="            NHDPROXF = 0x3B," line424="            NCLPROXF = 0x3C," line425="            FDLPROXF = 0x3D," line426="            NHDPROXT = 0x3E," line427="            NCLPROXT = 0x3F," line428="            FDLPROXT = 0x40," line429="            E0TTH = 0x41," line430="            E0RTH = 0x42," line431="            E1TTH = 0x43," line432="            E1RTH = 0x44," line433="            E2TTH = 0x45," line434="            E2RTH = 0x46," line435="            E3TTH = 0x47," line436="            E3RTH = 0x48," line437="            E4TTH = 0x49," line438="            E4RTH = 0x4A," line439="            E5TTH = 0x4B," line440="            E5RTH = 0x4C," line441="            E6TTH = 0x4D," line442="            E6RTH = 0x4E," line443="            E7TTH = 0x4F," line444="            E7RTH = 0x50," line445="            E8TTH = 0x51," line446="            E8RTH = 0x52," line447="            E9TTH = 0x53," line448="            E9RTH = 0x54," line449="            E10TTH = 0x55," line450="            E10RTH = 0x56," line451="            E11TTH = 0x57," line452="            E11RTH = 0x58," line453="            E12TTH = 0x59," line454="            E12RTH = 0x5A," line455="            DTR = 0x5B," line456="            AFE1 = 0x5C," line457="            AFE2 = 0x5D," line458="            ECR = 0x5E," line459="            CDC0 = 0x5F," line460="            CDC1 = 0x60," line461="            CDC2 = 0x62," line462="            CDC4 = 0x63," line463="            CDC5 = 0x64," line464="            CDC6 = 0x65," line465="            CDC7 = 0x66," line466="            CDC8 = 0x67," line467="            CDC9 = 0x68," line468="            CDC10 = 0x69," line469="            CDC11 = 0x6A," line470="            CDC12 = 0x6B," line471="            CDT_0_1 = 0x6C," line472="            CDT_2_3 = 0x6D," line473="            CDT_4_5 = 0x6E," line474="            CDT_6_7 = 0x6F," line475="            CDT_8_9 = 0x70," line476="            CDT_10_11 = 0x71," line477="            CDT_12 = 0x72," line478="            GPIO_CTL0 = 0x73," line479="            GPIO_CTL1 = 0x74," line480="            GPIO_DIR = 0x76," line481="            GPIO_EN = 0x77," line482="            GPIO_SET = 0x78," line483="            GPIO_CLR = 0x79," line484="            GPIO_TOG = 0x7A," line485="            AUTO_CONFIG_0 = 0x7B," line486="            AUTO_CONFIG_1 = 0x7C," line487="            AUTO_CONFIG_USL = 0x7D," line488="            AUTO_CONFIG_LSL = 0x7E," line489="            AUTO_CONFIG_TL = 0x7F" line490="        }" line491="" line492="        let commandDataBuffer: Buffer" line493="        let commandBuffer: Buffer" line494="" line495="        function writeCommandData(address: number, command: number, data: number): void {" line496="            if (!commandDataBuffer) {" line497="                commandDataBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt16BE))" line498="            }" line499="            commandDataBuffer.setNumber(NumberFormat.UInt16BE, 0, (command &lt;&lt; 8) | data)" line500="            pins.i2cWriteBuffer(address, commandDataBuffer)" line501="        }" line502="" line503="        function writeCommand(address: number, command: number): void {" line504="            if (!commandBuffer) {" line505="                commandBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt8BE))" line506="            }" line507="            commandBuffer.setNumber(NumberFormat.UInt8BE, 0, command)" line508="            pins.i2cWriteBuffer(address, commandBuffer)" line509="        }" line510="" line511="        export function configure(address: number, register: Config, value: number): void {" line512="            writeCommandData(address, register, value)" line513="        }" line514="" line515="        export function configureThresholds(address: number, touch: number, release: number): void {" line516="            for (let k = 0; k &lt; 12; k++) {" line517="                configure(address, Config.E0TTH + k * 2, touch)" line518="                configure(address, Config.E0RTH + k * 2, release)" line519="            }" line520="        }" line521="" line522="        export function reset(address: number): void {" line523="            writeCommandData(address, 0x80, 0x63)" line524="            basic.pause(30)" line525="        }" line526="" line527="        export function stop(address: number): void {" line528="            writeCommandData(address, Config.ECR, 0x0)" line529="        }" line530="" line531="        export function start(address: number, cl: CalibrationLock, eleprox: Proximity, ele: Touch): void {" line532="            writeCommandData(address, Config.ECR, (cl &lt;&lt; 6) | (eleprox &lt;&lt; 4) | ele)" line533="        }" line534="" line535="        export function readTouchStatus(address: number): number {" line536="            writeCommand(address, 0x0)" line537="            return pins.i2cReadNumber(address, NumberFormat.UInt16LE)" line538="        }" line539="    }" line540="" line541="    /**" line542="     * Code for the presence controller. (old and new Version, IR and ToF)" line543="     * by Moritz Metelmann" line544="     */" line545="" line546="    interface PresenceDetector {" line547="        lastPresenceDetection: boolean" line548="    }" line549="" line550="    let presenceDetector: PresenceDetector" line551="    const PRESENCE_DETECTED_ID = 2147" line552="" line553="    /**" line554="     * Initialize the presence controller." line555="     */" line556="" line557="    //% blockId=&quot;presence_init&quot; block=&quot;initialisiere Präsenz-Sensor&quot;" line558="    //% weight=70" line559="    function initPresenceDetector(): void {" line560="" line561="        if (!!presenceDetector) {" line562="            return" line563="        }" line564="" line565="        presenceDetector = {" line566="            lastPresenceDetection: false" line567="        }" line568="" line569="        Rangefinder.init();" line570="" line571="        control.inBackground(detectAndNotifyPresenceDetector)" line572="    }" line573="" line574="    function detectAndNotifyPresenceDetector() {" line575="        let previousPresenceStatus = false;" line576="        let priviousPresenceTime = control.millis();" line577="        while (true) {" line578="            let distance = Rangefinder.distance()" line579="            //basic.showNumber(Rangefinder.distance())" line580="            //basic.pause(2000)" line581="            if (previousPresenceStatus = false &amp;&amp; ((pins.digitalReadPin(DigitalPin.C9) == 0 &amp;&amp; distance == 0) || (distance &lt; 80 &amp;&amp; distance != 0))) {" line582="                control.raiseEvent(PRESENCE_DETECTED_ID, 0);" line583="                previousPresenceStatus = true;" line584="                priviousPresenceTime = control.millis();" line585="            }" line586="            if (previousPresenceStatus == true &amp;&amp; priviousPresenceTime &lt; control.millis() - 1000 &amp;&amp; ((pins.digitalReadPin(DigitalPin.C9) == 1 &amp;&amp; distance == 0) || distance &gt;= 80)) {" line587="                previousPresenceStatus = false;" line588="            }" line589="" line590="" line591="        }" line592="" line593="" line594="    }" line595="" line596="    //% blockId=smarthome_presence_detected" line597="    //% block=&quot;wenn Präsenz gemeldet&quot;" line598="    //% weight=65" line599="    export function onPresenceDetected(handler: () =&gt; void) {" line600="        initPresenceDetector();" line601="        control.onEvent(PRESENCE_DETECTED_ID, EventBusValue.MICROBIT_EVT_ANY, () =&gt; {" line602="            handler();" line603="        })" line604="    }" line605="}" numlines="606"></mutation><next><block type="block_dual_motor" id="}Ne:eL8OKwx]gRs6[ZPf"><field name="motor">Motor.M0</field><value name="percent"><shadow type="speedPicker" id="i-,zNQ|tEzD82Ev]d9e6"><field name="speed">0</field></shadow></value><next><block type="smarthome_SwitchLampOff" id="4n?G6H##;G+U)^zzU]PU"><field name="lampe">lampennamen.dl1</field><next><block type="smarthome_SwitchLampOff" id="vA6$Vckw,quHe8x.Wx=b"><field name="lampe">lampennamen.dl2</field><next><block type="smarthome_SwitchLampOff" id="KG0e]G!77t%HP:~Jm0q_"><field name="lampe">lampennamen.al</field><next><block type="smarthome_SwitchLampOff" id="(%-=wj})-_8V?c0Hbo-U"><field name="lampe">lampennamen.wl</field><next><block type="device_set_servo_pin" id="A%#4;D$6D-.J3(MuTDQI"><value name="name"><shadow type="analog_pin_shadow" id="T?1z4+F}vpnf?L~81*?W"><field name="pin">AnalogPin.C16</field></shadow></value><value name="value"><shadow type="math_number_minmax" id="M^BKL/Q1p|!rq)o+LP^Q"><mutation min="0" max="180" precision="0"></mutation><field name="SLIDER">0</field></shadow></value><next><block type="device_pause" id="1X8vllDKzEp72GEduq_}"><value name="pause"><shadow type="timePicker" id="/z(o5h/J.gteyx=%wNwe"><field name="ms">800</field></shadow></value><next><block type="device_set_servo_pulse" id="Z2!CYWkdLmAkCU}kY:(u"><value name="value"><shadow type="analog_pin_shadow" id="@5Um)tlAmpf4Mv8kI$@N"><field name="pin">AnalogPin.C16</field></shadow></value><value name="micros"><shadow type="math_number" id="5sh2;Qu{=c3wNmV[BSzd"><field name="NUM">0</field></shadow></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block><block type="smarthome_presence_detected" id="u.@]bCK[g25z!p4t?`eI" x="493" y="32"><statement name="HANDLER"><block type="device_play_note" id="GwXX26O%ERul?pI{)N6k"><value name="note"><shadow type="device_note" id="-YvF{J-d~_.U![5oBo=C"><field name="name">262</field></shadow></value><value name="duration"><shadow type="device_beat" id=",_~$2Q[w+;rfBUpxb[2#"><field name="fraction">BeatFraction.Whole</field></shadow></value></block></statement></block><block type="device_forever" id="BpJ!6U!W:DE2{EG!!^}Q" x="1840" y="-32"></block></xml>