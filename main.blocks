<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="L[e%v~!oEy;bzCy(iDrT" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="L}j~$pBb@`6%9TA0Q#8F"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum TouchSensor {" line1="    S0 = 0b000000000001," line2="    S1 = 0b000000000010," line3="    S2 = 0b000000000100," line4="    S3 = 0b000000001000," line5="    S4 = 0b000000010000," line6="    S5 = 0b000000100000," line7="    S6 = 0b000001000000," line8="    S7 = 0b000010000000," line9="    S8 = 0b000100000000," line10="    S9 = 0b001000000000," line11="    // T10 = 0b010000000000, //not used" line12="    // T11 = 0b100000000000. //not used" line13="}" numlines="14"></mutation><next><block type="typescript_statement" id="/5:MjAk3DrI=Q,X3~,Al"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum onoff {" line1="    //% block=&quot;an&quot;" line2="    on = 1," line3="    //% block=&quot;aus&quot;" line4="    off = 2," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="1^Z_(B?Nx=aSgm`$;9N+"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum openclose {" line1="    //% block=&quot;öffnen&quot;" line2="    open = 1," line3="    //% block=&quot;schließen&quot;" line4="    close = 2," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="}RY1o8bG*{mb]4S~1LH~"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum lampennamen {" line1="    //% block=&quot;Deckenlampe 1&quot;" line2="    dl1 = 1," line3="    //% block=&quot;Deckenlampe 2&quot;" line4="    dl2 = 0," line5="    //% block=&quot;Außenlampe&quot;" line6="    al = 2," line7="    //% block=&quot;Wandlampe&quot;" line8="    wl = 3" line9="}" numlines="10"></mutation><next><block type="typescript_statement" id="i1]UORLsskiXBOi%^p#u"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace smarthome {" line1="" line2="    /**" line3="     * Code für den Rolladen" line4="     * by Moritz Metelmann" line5="     */" line6="" line7="    let shades_open: boolean = false;" line8="" line9="    /**" line10="    * Öffnet/Schließt den Rolladen" line11="    */" line12="    //% block=&quot;$state shades&quot;" line13="    //% block.loc.de=&quot;Rolladen $state&quot;" line14="    //% inlineInputMode=inline" line15="    export function SwitchShades(state: openclose = openclose.open) {" line16="        if (state === openclose.open) {" line17="            pins.servoWritePin(AnalogPin.C16, 0)" line18="            basic.pause(800)" line19="            pins.servoSetPulse(AnalogPin.C16, 0)" line20="            shades_open = true;" line21="        } else {" line22="            pins.servoWritePin(AnalogPin.C16, 180)" line23="            basic.pause(800)" line24="            pins.servoSetPulse(AnalogPin.C16, 0)" line25="            shades_open = false;" line26="        }" line27="    }" line28="" line29="    /**" line30="    * Ist der Rolladen offen?" line31="    */" line32="    //% block=&quot;shade is open&quot;" line33="    //% block.loc.de=&quot;Rolladen ist offen&quot;" line34="    //% weight=5" line35="    //% group=&quot;Zustände&quot;" line36="    export function GetShadesStatus(): boolean {" line37="        return shades_open;" line38="    }" line39="" line40="    /**" line41="     * Code für die Klimaanlage" line42="     * by Moritz Metelmann" line43="     */" line44="" line45="    let ac_on: boolean = false;" line46="" line47="    /**" line48="    * Schaltet die Klimaanlage an/aus" line49="    */" line50="    //% block=&quot;switch aircondition $state&quot;" line51="    //% block.loc.de=&quot;schalte die Klimaanlage $state&quot;" line52="    //% inlineInputMode=inline" line53="    //% weight=5" line54="    export function SwitchAC(state: onoff = onoff.on) {" line55="        if (state === onoff.on) {" line56="            motors.dualMotorPower(Motor.M0, 100)" line57="            ac_on = true;" line58="        } else {" line59="            motors.dualMotorPower(Motor.M0, 0)" line60="            ac_on = false;" line61="        }" line62="    }" line63="" line64="    /**" line65="    * Schaltet die Klimaanlage auf eine prozentuale Geschwindikteit" line66="    */" line67="    //% blockId=CalliBrightness block=&quot;set aircondition to %c %&quot;" line68="    //% block.loc.de=&quot;setze Klimaanlage auf %c %&quot;" line69="    //% c.defl=80" line70="    //% c.min=25 c.max=100" line71="    export function DimAC(c: number) {" line72="        if (c &lt; 25) {" line73="            c = 25" line74="        }" line75="        if (c &gt; 100) {" line76="            c = 100" line77="        }" line78="        motors.dualMotorPower(Motor.M0, c)" line79="        ac_on = true;" line80="    }" line81="" line82="    /**" line83="    * Ist die Klimaanlage an?" line84="    */" line85="    //% block=&quot;aircondition is on&quot;" line86="    //% block.loc.de=&quot;Klimaanlage ist an&quot;" line87="    //% weight=5" line88="    //% group=&quot;Zustände&quot;" line89="    export function GetACStatus(): boolean {" line90="        return ac_on;" line91="    }" line92="" line93="    /**" line94="     * Code für NeoPixel LED's (Lampen)" line95="     * based on https://github.com/MKleinSB/pxt-callicolor/blob/master/callicolor.ts" line96="     * by Michael Klein which took parts from" line97="     * https://github.com/BrightWearables/pxt-microbit-brightboard" line98="     */" line99="" line100="    let Lampen = neopixel.create(DigitalPin.C8, 11, NeoPixelMode.RGB)" line101="    let dl2 = Lampen.range(0, 0);" line102="    let dl1 = Lampen.range(1, 1);" line103="    let al = Lampen.range(2, 2);" line104="    let wl = Lampen.range(3, 10);" line105="" line106="    let lampen_state = [false, false, false, false];" line107="" line108="    let ccolors = [0xff0000, 0xFF7F00, 0xFFFE00, 0x7FFF00, 0x00FF00, 0x00FF7F," line109="        0x00FFFE, 0x0040FF, 0x0000FF, 0x6000FF, 0xFE00FF, 0xFF0040]" line110="" line111="    //% block=&quot;set wall light to $color1 $color2 $color3 $color4 $color5 $color6 $color7 $color8&quot;" line112="    //% block.loc.de=&quot;setze Wandlampe auf $color1 $color2 $color3 $color4 $color5 $color6 $color7 $color8&quot;       " line113="    //% color1.shadow=&quot;LampenColorNumberPicker&quot;  color1.defl=0xff0000" line114="    //% color2.shadow=&quot;LampenColorNumberPicker&quot;  color2.defl=0xff8000" line115="    //% color3.shadow=&quot;LampenColorNumberPicker&quot;  color3.defl=0xffff00" line116="    //% color4.shadow=&quot;LampenColorNumberPicker&quot;  color4.defl=0x00ff00" line117="    //% color5.shadow=&quot;LampenColorNumberPicker&quot;  color5.defl=0x00ffff" line118="    //% color6.shadow=&quot;LampenColorNumberPicker&quot;  color6.defl=0x0000ff" line119="    //% color7.shadow=&quot;LampenColorNumberPicker&quot;  color7.defl=0xff00ff" line120="    //% color8.shadow=&quot;LampenColorNumberPicker&quot;  color8.defl=0xff0080" line121="    //% inlineInputMode=inline" line122="    export function ShowWallLampColorPixel(color1: number, color2: number, color3: number, color4: number, color5: number, color6: number, color7: number, color8: number) {" line123="        Lampen.setBrightness(20);" line124="        Lampen.setPixelColor(3, color1)" line125="        Lampen.setPixelColor(4, color2)" line126="        Lampen.setPixelColor(5, color3)" line127="        Lampen.setPixelColor(6, color4)" line128="        Lampen.setPixelColor(7, color5)" line129="        Lampen.setPixelColor(8, color6)" line130="        Lampen.setPixelColor(9, color7)" line131="        Lampen.setPixelColor(10, color8)" line132="        Lampen.show()" line133="        Lampen.setBrightness(255);" line134="        if (color1 != 0x000000 || color2 != 0x000000 || color3 != 0x000000 || color4 != 0x000000 || color5 != 0x000000 || color6 != 0x000000 || color7 != 0x000000 || color8 != 0x000000) {" line135="            lampen_state[3] = true;" line136="        } else {" line137="            lampen_state[3] = false;" line138="        }" line139="    }" line140="" line141="    /**" line142="    * Schalte eine Lampe in einer Farbe" line143="    */" line144="    //% block=&quot;set $lampe to $color&quot;" line145="    //% block.loc.de=&quot;setze $lampe auf $color&quot;" line146="    //% color.shadow=&quot;LampenColorNumberPicker&quot; color.defl='#ffffff'" line147="    //% inlineInputMode=inline" line148="    export function ShowLampColor(lampe: lampennamen = lampennamen.dl1, color: number) {" line149="        if (lampe &lt; 3) {" line150="            if (color == 0x909090) {" line151="                color = 0x404040;" line152="            } else if (color == 0x505050) {" line153="                color = 0x101010;" line154="            }" line155="            Lampen.setPixelColor(lampe, color)" line156="            if (color != 0x000000) {" line157="                lampen_state[lampe] = true;" line158="            } else {" line159="                lampen_state[lampe] = false;" line160="            }" line161="        } else { // Wandlampe" line162="            wl.setBrightness(20)" line163="            wl.showColor(color)" line164="            if (color != 0x000000) {" line165="                lampen_state[3] = true;" line166="            } else {" line167="                lampen_state[3] = false;" line168="            }" line169="        }" line170="        Lampen.show()" line171="        wl.setBrightness(255)" line172="    }" line173="" line174="    /**" line175="    * Schalte eine Lampe aus" line176="    */" line177="    //% block=&quot;switch $lampe off&quot;" line178="    //% block.loc.de=&quot;schalte $lampe aus&quot;" line179="    //% inlineInputMode=inline" line180="    export function SwitchLampOff(lampe: lampennamen = lampennamen.dl1) {" line181="        if (lampe &lt; 3) {" line182="            Lampen.setPixelColor(lampe, 0x000000)" line183="        } else { // Wandlampe" line184="            wl.showColor(0x000000)" line185="        }" line186="        lampen_state[lampe] = false;" line187="        Lampen.show()" line188="    }" line189="" line190="    /**" line191="    * Gibt den Status einer Lampe zurück" line192="    */" line193="    //% block=&quot;$lampe is on&quot;" line194="    //% block.loc.de=&quot;$lampe ist an&quot;" line195="    //% inlineInputMode=inline" line196="    //% weight=5" line197="    //% group=&quot;Zustände&quot;" line198="    export function GetLampStatus(lampe: lampennamen = lampennamen.dl1): boolean {" line199="        return lampen_state[lampe];" line200="    }" line201="" line202="    /**" line203="    * Custom color picker" line204="    */" line205="    //% blockId=LampenColorNumberPicker block=&quot;%value&quot;" line206="    //% blockHidden=true" line207="    //% shim=TD_ID" line208="    //% value.fieldEditor=&quot;colornumber&quot; value.fieldOptions.decompileLiterals=true" line209="    //% weight=150" line210="    //% value.fieldOptions.colours='[&quot;#ff0000&quot;,&quot;#ff8000&quot;,&quot;#ffff00&quot;,&quot;#00ff00&quot;,&quot;#00ffff&quot;,&quot;#0000ff&quot;,&quot;#ff00ff&quot;,&quot;#ff0080&quot;,&quot;#ffffff&quot;,&quot;#909090&quot;,&quot;#505050&quot;,&quot;#000000&quot;]'" line211="    //% value.fieldOptions.columns=4 value.fieldOptions.className='rgbColorPicker'  " line212="    export function CalliColorNumberPicker(value: number) {" line213="        return value;" line214="    }" line215="" line216="    /**" line217="     * Code für die Touch Schalter" line218="     * based on https://github.com/mkleinsb/pxt-mpr121 by Michael Klein" line219="     * mpr 121 touch blocks based on touch.ts 0.17.5" line220="     * Auf Basis von https://github.com/1010Technologies/pxt-makerbit" line221="     * Copyright (c) 2018 Roger Wagner, Philipp Henkel &amp; Michael Klein" line222="     * MIT License" line223="     */" line224="" line225="    const MPR121_ADDRESS = 0x5A" line226="    const TOUCH_STATUS_PAUSE_BETWEEN_READ = 50" line227="" line228="    interface TouchController {" line229="        lastTouchStatus: number" line230="        lastEventValue: number" line231="    }" line232="" line233="    let touchController: TouchController" line234="" line235="    const MPR121_TOUCH_SENSOR_TOUCHED_ID = 2148" line236="    const MPR121_TOUCH_SENSOR_RELEASED_ID = 2149" line237="" line238="" line239="    /**" line240="     * Initialize the touch controller." line241="     */" line242="" line243="    //% blockId=&quot;mpr121_touch_init&quot; block=&quot;initialisiere touch-Sensor&quot;" line244="    //% weight=70" line245="    function initTouchController(): void {" line246="" line247="        if (!!touchController) {" line248="            return" line249="        }" line250="" line251="        touchController = {" line252="            lastTouchStatus: 0," line253="            lastEventValue: 0," line254="        }" line255="" line256="        const addr = MPR121_ADDRESS" line257="        mpr121.reset(addr)" line258="" line259="        // Stop capture" line260="        mpr121.stop(addr)" line261="" line262="        // Input filter for rising state" line263="        mpr121.configure(addr, mpr121.Config.MHDR, 0x01)" line264="        mpr121.configure(addr, mpr121.Config.NHDR, 0x01)" line265="        mpr121.configure(addr, mpr121.Config.NCLR, 0x10)" line266="        mpr121.configure(addr, mpr121.Config.FDLR, 0x20)" line267="" line268="        // Input filter for falling state" line269="        mpr121.configure(addr, mpr121.Config.MHDF, 0x01)" line270="        mpr121.configure(addr, mpr121.Config.NHDF, 0x01)" line271="        mpr121.configure(addr, mpr121.Config.NCLF, 0x10)" line272="        mpr121.configure(addr, mpr121.Config.FDLF, 0x20)" line273="" line274="        // Input filter for touched state" line275="        mpr121.configure(addr, mpr121.Config.NHDT, 0x01)" line276="        mpr121.configure(addr, mpr121.Config.NCLT, 0x10)" line277="        mpr121.configure(addr, mpr121.Config.FDLT, 0xFF)" line278="" line279="        // Unused proximity sensor filter" line280="        mpr121.configure(addr, mpr121.Config.MHDPROXR, 0x0F)" line281="        mpr121.configure(addr, mpr121.Config.NHDPROXR, 0x0F)" line282="        mpr121.configure(addr, mpr121.Config.NCLPROXR, 0x00)" line283="        mpr121.configure(addr, mpr121.Config.FDLPROXR, 0x00)" line284="        mpr121.configure(addr, mpr121.Config.MHDPROXF, 0x01)" line285="        mpr121.configure(addr, mpr121.Config.NHDPROXF, 0x01)" line286="        mpr121.configure(addr, mpr121.Config.NCLPROXF, 0xFF)" line287="        mpr121.configure(addr, mpr121.Config.FDLPROXF, 0xFF)" line288="        mpr121.configure(addr, mpr121.Config.NHDPROXT, 0x00)" line289="        mpr121.configure(addr, mpr121.Config.NCLPROXT, 0x00)" line290="        mpr121.configure(addr, mpr121.Config.FDLPROXT, 0x00)" line291="" line292="        // Debounce configuration (used primarily for interrupts)" line293="        mpr121.configure(addr, mpr121.Config.DTR, 0x11)" line294="" line295="        // Electrode clock frequency etc" line296="        mpr121.configure(addr, mpr121.Config.AFE1, 0xFF)" line297="        mpr121.configure(addr, mpr121.Config.AFE2, 0x30)" line298="" line299="        // Enable autoconfiguration / calibration" line300="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_0, 0x00)" line301="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_1, 0x00)" line302="" line303="        // Tuning parameters for the autocalibration algorithm" line304="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_USL, 0x00)" line305="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_LSL, 0x00)" line306="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_TL, 0x00)" line307="" line308="        // Default sensitivity thresholds" line309="        mpr121.configureThresholds(addr, 60, 20)" line310="" line311="        // Restart capture" line312="        mpr121.start(" line313="            addr," line314="            mpr121.CalibrationLock.BaselineTrackingAndInitialize," line315="            mpr121.Proximity.DISABLED," line316="            mpr121.Touch.ELE_0_TO_11" line317="        )" line318="        control.inBackground(detectAndNotifyTouchEvents)" line319="    }" line320="" line321="    function detectAndNotifyTouchEvents() {" line322="        let previousTouchStatus = 0" line323="" line324="        while (true) {" line325="            const touchStatus = mpr121.readTouchStatus(MPR121_ADDRESS)" line326="            touchController.lastTouchStatus = touchStatus" line327="" line328="            for (let touchSensorBit = 1; touchSensorBit &lt;= 2048; touchSensorBit &lt;&lt;= 1) {" line329="" line330="                // Raise event when touch starts" line331="                if ((touchSensorBit &amp; touchStatus) !== 0) {" line332="                    if (!((touchSensorBit &amp; previousTouchStatus) !== 0)) {" line333="                        control.raiseEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, touchSensorBit)" line334="                        touchController.lastEventValue = touchSensorBit" line335="                    }" line336="                }" line337="" line338="                // Raise event when touch ends" line339="                if ((touchSensorBit &amp; touchStatus) === 0) {" line340="                    if (!((touchSensorBit &amp; previousTouchStatus) === 0)) {" line341="                        control.raiseEvent(MPR121_TOUCH_SENSOR_RELEASED_ID, touchSensorBit)" line342="                        touchController.lastEventValue = touchSensorBit" line343="                    }" line344="                }" line345="            }" line346="" line347="            previousTouchStatus = touchStatus" line348="" line349="            basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line350="        }" line351="    }" line352="" line353="    /**" line354="     * Mache etwas, wenn ein spezieller Sensor berührt wird." line355="     * Dieses Touch-Ereignis wird direkt zu Beginn der Berührung ausgeführt." line356="     * @param sensor der Touchsensor der überwacht werden soll, z.B.: TouchSensor.T0" line357="     * @param handler body code der bei der Berührung des Sensors ausgeführt werden soll" line358="    */" line359="" line360="    //% blockId=mpr121_touch_on_touch_sensor_down" line361="    //% block=&quot;wenn Schalter | %sensor | gedrückt&quot;" line362="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=3" line363="    //% sensor.fieldOptions.tooltips=&quot;false&quot;" line364="    //% weight=65" line365="    export function onTouchSensorTouched(sensor: TouchSensor, handler: () =&gt; void) {" line366="        initTouchController()" line367="        control.onEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, sensor, () =&gt; {" line368="            setupContextAndNotify(handler)" line369="        })" line370="    }" line371="" line372="    function setupContextAndNotify(handler: () =&gt; void) {" line373="        touchController.lastEventValue = control.eventValue()" line374="        handler()" line375="    }" line376="" line377="    // Communication module for MPR121 capacitive touch sensor controller" line378="    // https://www.sparkfun.com/datasheets/Components/MPR121.pdf" line379="    export namespace mpr121 {" line380="" line381="        export enum CalibrationLock {" line382="            BaselineTrackingOn = 0b00," line383="            BaselineTrackingOff = 0b01," line384="            BaselineTrackingAndInitializeFirst5MSB = 0b10," line385="            BaselineTrackingAndInitialize = 0b11" line386="        }" line387="" line388="        export enum Proximity {" line389="            DISABLED = 0b00," line390="            ELE0_TO_1 = 0b01," line391="            ELE_0_TO_3 = 0b10," line392="            ELE_0_TO_11 = 0b11" line393="        }" line394="" line395="        export enum Touch {" line396="            DISABLED = 0b0000," line397="            ELE_0 = 0b0001," line398="            ELE_0_TO_1 = 0b0010," line399="            ELE_0_TO_2 = 0b0011," line400="            ELE_0_TO_3 = 0b0100," line401="            ELE_0_TO_4 = 0b0101," line402="            ELE_0_TO_5 = 0b0110," line403="            ELE_0_TO_6 = 0b0111," line404="            ELE_0_TO_7 = 0b1000," line405="            ELE_0_TO_8 = 0b1001," line406="            ELE_0_TO_9 = 0b1010," line407="            ELE_0_TO_10 = 0b1011," line408="            ELE_0_TO_11 = 0b1100" line409="        }" line410="" line411="        export enum Config {" line412="            MHDR = 0x2B," line413="            NHDR = 0x2C," line414="            NCLR = 0x2D," line415="            FDLR = 0x2E," line416="            MHDF = 0x2F," line417="            NHDF = 0x30," line418="            NCLF = 0x31," line419="            FDLF = 0x32," line420="            NHDT = 0x33," line421="            NCLT = 0x34," line422="            FDLT = 0x35," line423="            MHDPROXR = 0x36," line424="            NHDPROXR = 0x37," line425="            NCLPROXR = 0x38," line426="            FDLPROXR = 0x39," line427="            MHDPROXF = 0x3A," line428="            NHDPROXF = 0x3B," line429="            NCLPROXF = 0x3C," line430="            FDLPROXF = 0x3D," line431="            NHDPROXT = 0x3E," line432="            NCLPROXT = 0x3F," line433="            FDLPROXT = 0x40," line434="            E0TTH = 0x41," line435="            E0RTH = 0x42," line436="            E1TTH = 0x43," line437="            E1RTH = 0x44," line438="            E2TTH = 0x45," line439="            E2RTH = 0x46," line440="            E3TTH = 0x47," line441="            E3RTH = 0x48," line442="            E4TTH = 0x49," line443="            E4RTH = 0x4A," line444="            E5TTH = 0x4B," line445="            E5RTH = 0x4C," line446="            E6TTH = 0x4D," line447="            E6RTH = 0x4E," line448="            E7TTH = 0x4F," line449="            E7RTH = 0x50," line450="            E8TTH = 0x51," line451="            E8RTH = 0x52," line452="            E9TTH = 0x53," line453="            E9RTH = 0x54," line454="            E10TTH = 0x55," line455="            E10RTH = 0x56," line456="            E11TTH = 0x57," line457="            E11RTH = 0x58," line458="            E12TTH = 0x59," line459="            E12RTH = 0x5A," line460="            DTR = 0x5B," line461="            AFE1 = 0x5C," line462="            AFE2 = 0x5D," line463="            ECR = 0x5E," line464="            CDC0 = 0x5F," line465="            CDC1 = 0x60," line466="            CDC2 = 0x62," line467="            CDC4 = 0x63," line468="            CDC5 = 0x64," line469="            CDC6 = 0x65," line470="            CDC7 = 0x66," line471="            CDC8 = 0x67," line472="            CDC9 = 0x68," line473="            CDC10 = 0x69," line474="            CDC11 = 0x6A," line475="            CDC12 = 0x6B," line476="            CDT_0_1 = 0x6C," line477="            CDT_2_3 = 0x6D," line478="            CDT_4_5 = 0x6E," line479="            CDT_6_7 = 0x6F," line480="            CDT_8_9 = 0x70," line481="            CDT_10_11 = 0x71," line482="            CDT_12 = 0x72," line483="            GPIO_CTL0 = 0x73," line484="            GPIO_CTL1 = 0x74," line485="            GPIO_DIR = 0x76," line486="            GPIO_EN = 0x77," line487="            GPIO_SET = 0x78," line488="            GPIO_CLR = 0x79," line489="            GPIO_TOG = 0x7A," line490="            AUTO_CONFIG_0 = 0x7B," line491="            AUTO_CONFIG_1 = 0x7C," line492="            AUTO_CONFIG_USL = 0x7D," line493="            AUTO_CONFIG_LSL = 0x7E," line494="            AUTO_CONFIG_TL = 0x7F" line495="        }" line496="" line497="        let commandDataBuffer: Buffer" line498="        let commandBuffer: Buffer" line499="" line500="        function writeCommandData(address: number, command: number, data: number): void {" line501="            if (!commandDataBuffer) {" line502="                commandDataBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt16BE))" line503="            }" line504="            commandDataBuffer.setNumber(NumberFormat.UInt16BE, 0, (command &lt;&lt; 8) | data)" line505="            pins.i2cWriteBuffer(address, commandDataBuffer)" line506="        }" line507="" line508="        function writeCommand(address: number, command: number): void {" line509="            if (!commandBuffer) {" line510="                commandBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt8BE))" line511="            }" line512="            commandBuffer.setNumber(NumberFormat.UInt8BE, 0, command)" line513="            pins.i2cWriteBuffer(address, commandBuffer)" line514="        }" line515="" line516="        export function configure(address: number, register: Config, value: number): void {" line517="            writeCommandData(address, register, value)" line518="        }" line519="" line520="        export function configureThresholds(address: number, touch: number, release: number): void {" line521="            for (let k = 0; k &lt; 12; k++) {" line522="                configure(address, Config.E0TTH + k * 2, touch)" line523="                configure(address, Config.E0RTH + k * 2, release)" line524="            }" line525="        }" line526="" line527="        export function reset(address: number): void {" line528="            writeCommandData(address, 0x80, 0x63)" line529="            basic.pause(30)" line530="        }" line531="" line532="        export function stop(address: number): void {" line533="            writeCommandData(address, Config.ECR, 0x0)" line534="        }" line535="" line536="        export function start(address: number, cl: CalibrationLock, eleprox: Proximity, ele: Touch): void {" line537="            writeCommandData(address, Config.ECR, (cl &lt;&lt; 6) | (eleprox &lt;&lt; 4) | ele)" line538="        }" line539="" line540="        export function readTouchStatus(address: number): number {" line541="            writeCommand(address, 0x0)" line542="            return pins.i2cReadNumber(address, NumberFormat.UInt16LE)" line543="        }" line544="    }" line545="" line546="    /**" line547="     * Code for the presence controller. (old and new Version, IR and ToF)" line548="     * by Moritz Metelmann" line549="     */" line550="" line551="    interface PresenceDetector {" line552="        lastPresenceDetection: boolean" line553="    }" line554="" line555="    let presenceDetector: PresenceDetector" line556="    const PRESENCE_DETECTED_ID = 2147" line557="" line558="    /**" line559="     * Initialize the presence controller." line560="     */" line561="" line562="    //% blockId=&quot;presence_init&quot; block=&quot;initialisiere Präsenz-Sensor&quot;" line563="    //% weight=70" line564="    function initPresenceDetector(): void {" line565="" line566="        if (!!presenceDetector) {" line567="            return" line568="        }" line569="" line570="        presenceDetector = {" line571="            lastPresenceDetection: false" line572="        }" line573="" line574="        Rangefinder.init();" line575="" line576="        control.inBackground(detectAndNotifyPresenceDetector)" line577="    }" line578="" line579="    function detectAndNotifyPresenceDetector() {" line580="        let previousPresenceStatus = false;" line581="" line582="        while (true) {" line583="            if (previousPresenceStatus == false &amp;&amp; (pins.digitalReadPin(DigitalPin.C9) == 0 || Rangefinder.distance() &lt; 80)) {" line584="                control.raiseEvent(PRESENCE_DETECTED_ID, 0);" line585="                previousPresenceStatus = true;" line586="            }" line587="            if (previousPresenceStatus == true &amp;&amp; (pins.digitalReadPin(DigitalPin.C9) == 1 &amp;&amp; (Rangefinder.distance() &gt;= 80 || Rangefinder.distance() == 0))) {" line588="                previousPresenceStatus = false;" line589="                basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line590="            }" line591="" line592="" line593="        }" line594="" line595="" line596="    }" line597="" line598="    //% blockId=smarthome_presence_detected" line599="    //% block=&quot;wenn Präsenz gemeldet&quot;" line600="    //% weight=65" line601="    export function onPresenceDetected(handler: () =&gt; void) {" line602="        initPresenceDetector();" line603="        control.onEvent(PRESENCE_DETECTED_ID, EventBusValue.MICROBIT_EVT_ANY, () =&gt; {" line604="            handler();" line605="        })" line606="    }" line607="}" numlines="608"></mutation></block></next></block></next></block></next></block></next></block></statement></block><block type="device_forever" id="9q1K.OcN-?sS!8[?_UtW" x="1855" y="-40"></block></xml>