<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="v3C5B,{M#eJi!n}{S-Z|" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="}@dWGJ2.Ry5*K/.-|L{X"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum TouchSensor {" line1="    S0 = 0b000000000001," line2="    S1 = 0b000000000010," line3="    S2 = 0b000000000100," line4="    S3 = 0b000000001000," line5="    S4 = 0b000000010000," line6="    S5 = 0b000000100000," line7="    S6 = 0b000001000000," line8="    S7 = 0b000010000000," line9="    S8 = 0b000100000000," line10="    S9 = 0b001000000000," line11="    // T10 = 0b010000000000, //not used" line12="    // T11 = 0b100000000000. //not used" line13="}" numlines="14"></mutation><next><block type="typescript_statement" id="tI](kv.Hp^DAH%m(J|@j"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum onoff {" line1="    //% block=&quot;an&quot;" line2="    on = 1," line3="    //% block=&quot;aus&quot;" line4="    off = 2," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="KAdLDuZ~$^*G15/)oNT%"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum openclose {" line1="    //% block=&quot;öffnen&quot;" line2="    open = 1," line3="    //% block=&quot;schließen&quot;" line4="    close = 2," line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="^/iXy!|y|^QP#:|ocDP8"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum lampennamen {" line1="    //% block=&quot;Deckenlampe 1&quot;" line2="    dl1 = 1," line3="    //% block=&quot;Deckenlampe 2&quot;" line4="    dl2 = 0," line5="    //% block=&quot;Außenlampe&quot;" line6="    al = 2," line7="    //% block=&quot;Wandlampe&quot;" line8="    wl = 3" line9="}" numlines="10"></mutation><next><block type="typescript_statement" id="2c,(@.%Iet66uqgSzd{r"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace smarthome {" line1="" line2="    /**" line3="     * Code für den Rolladen" line4="     * by Moritz Metelmann" line5="     */" line6="" line7="    let shades_open: boolean = false;" line8="" line9="    /**" line10="    * Öffnet/Schließt den Rolladen" line11="    */" line12="    //% block=&quot;$state shades&quot;" line13="    //% block.loc.de=&quot;Rolladen $state&quot;" line14="    //% inlineInputMode=inline" line15="    export function SwitchShades(state: openclose = openclose.open) {" line16="        if (state === openclose.open) {" line17="            pins.servoWritePin(AnalogPin.C16, 0)" line18="            basic.pause(800)" line19="            pins.servoSetPulse(AnalogPin.C16, 0)" line20="            shades_open = true;" line21="        } else {" line22="            pins.servoWritePin(AnalogPin.C16, 180)" line23="            basic.pause(800)" line24="            pins.servoSetPulse(AnalogPin.C16, 0)" line25="            shades_open = false;" line26="        }" line27="    }" line28="" line29="    /**" line30="    * Ist der Rolladen offen?" line31="    */" line32="    //% block=&quot;shade is open&quot;" line33="    //% block.loc.de=&quot;Rolladen ist offen&quot;" line34="    //% weight=5" line35="    //% group=&quot;Zustände&quot;" line36="    export function GetShadesStatus(): boolean {" line37="        return shades_open;" line38="    }" line39="" line40="    /**" line41="     * Code für die Klimaanlage" line42="     * by Moritz Metelmann" line43="     */" line44="" line45="    let ac_on: boolean = false;" line46="" line47="    /**" line48="    * Schaltet die Klimaanlage an/aus" line49="    */" line50="    //% block=&quot;switch aircondition $state&quot;" line51="    //% block.loc.de=&quot;schalte die Klimaanlage $state&quot;" line52="    //% inlineInputMode=inline" line53="    //% weight=5" line54="    export function SwitchAC(state: onoff = onoff.on) {" line55="        if (state === onoff.on) {" line56="            motors.dualMotorPower(Motor.M0, 100)" line57="            ac_on = true;" line58="        } else {" line59="            motors.dualMotorPower(Motor.M0, 0)" line60="            ac_on = false;" line61="        }" line62="    }" line63="" line64="    /**" line65="    * Schaltet die Klimaanlage auf eine prozentuale Geschwindikteit" line66="    */" line67="    //% blockId=CalliBrightness block=&quot;set aircondition to %c %&quot;" line68="    //% block.loc.de=&quot;setze Klimaanlage auf %c %&quot;" line69="    //% c.defl=80" line70="    //% c.min=25 c.max=100" line71="    export function DimAC(c: number) {" line72="        if (c &lt; 25) {" line73="            c = 25" line74="        }" line75="        if (c &gt; 100) {" line76="            c = 100" line77="        }" line78="        motors.dualMotorPower(Motor.M0, c)" line79="        ac_on = true;" line80="    }" line81="" line82="    /**" line83="    * Ist die Klimaanlage an?" line84="    */" line85="    //% block=&quot;aircondition is on&quot;" line86="    //% block.loc.de=&quot;Klimaanlage ist an&quot;" line87="    //% weight=5" line88="    //% group=&quot;Zustände&quot;" line89="    export function GetACStatus(): boolean {" line90="        return ac_on;" line91="    }" line92="" line93="    /**" line94="     * Code für NeoPixel LED's (Lampen)" line95="     * based on https://github.com/MKleinSB/pxt-callicolor/blob/master/callicolor.ts" line96="     * by Michael Klein which took parts from" line97="     * https://github.com/BrightWearables/pxt-microbit-brightboard" line98="     */" line99="" line100="    let Lampen = neopixel.create(DigitalPin.C8, 11, NeoPixelMode.RGB)" line101="    let dl2 = Lampen.range(0, 0);" line102="    let dl1 = Lampen.range(1, 1);" line103="    let al = Lampen.range(2, 2);" line104="    let wl = Lampen.range(3, 10);" line105="" line106="    let lampen_state = [false, false, false, false];" line107="" line108="    let ccolors = [0xff0000, 0xFF7F00, 0xFFFE00, 0x7FFF00, 0x00FF00, 0x00FF7F," line109="        0x00FFFE, 0x0040FF, 0x0000FF, 0x6000FF, 0xFE00FF, 0xFF0040]" line110="" line111="    //% block=&quot;set wall light to $color1 $color2 $color3 $color4 $color5 $color6 $color7 $color8&quot;" line112="    //% block.loc.de=&quot;setze Wandlampe auf $color1 $color2 $color3 $color4 $color5 $color6 $color7 $color8&quot;       " line113="    //% color1.shadow=&quot;LampenColorNumberPicker&quot;  color1.defl=0xff0000" line114="    //% color2.shadow=&quot;LampenColorNumberPicker&quot;  color2.defl=0xFF7F00" line115="    //% color3.shadow=&quot;LampenColorNumberPicker&quot;  color3.defl=0xFFFE00" line116="    //% color4.shadow=&quot;LampenColorNumberPicker&quot;  color4.defl=0x7FFF00" line117="    //% color5.shadow=&quot;LampenColorNumberPicker&quot;  color5.defl=0x00FF00" line118="    //% color6.shadow=&quot;LampenColorNumberPicker&quot;  color6.defl=0x00FF7F" line119="    //% color7.shadow=&quot;LampenColorNumberPicker&quot;  color7.defl=0x00FFFE" line120="    //% color8.shadow=&quot;LampenColorNumberPicker&quot;  color8.defl=0x0040FF" line121="    //% inlineInputMode=inline" line122="    export function ShowWallLampColorPixel(color1: number, color2: number, color3: number, color4: number, color5: number, color6: number, color7: number, color8: number) {" line123="        Lampen.setPixelColor(3, color1)" line124="        Lampen.setPixelColor(4, color2)" line125="        Lampen.setPixelColor(5, color3)" line126="        Lampen.setPixelColor(6, color4)" line127="        Lampen.setPixelColor(7, color5)" line128="        Lampen.setPixelColor(8, color6)" line129="        Lampen.setPixelColor(9, color7)" line130="        Lampen.setPixelColor(10, color8)" line131="        Lampen.show()" line132="        if (color1 != 0x000000 || color2 != 0x000000 || color3 != 0x000000 || color4 != 0x000000 || color5 != 0x000000 || color6 != 0x000000 || color7 != 0x000000 || color8 != 0x000000) {" line133="            lampen_state[3] = true;" line134="        } else {" line135="            lampen_state[3] = false;" line136="        }" line137="    }" line138="" line139="    /**" line140="    * Schalte eine Lampe in einer Farbe" line141="    */" line142="    //% block=&quot;set $lampe to $color&quot;" line143="    //% block.loc.de=&quot;setze $lampe auf $color&quot;" line144="    //% color.shadow=&quot;LampenColorNumberPicker&quot; color.defl='#ffffff'" line145="    //% inlineInputMode=inline" line146="    export function ShowLampColor(lampe: lampennamen = lampennamen.dl1, color: number) {" line147="        if (lampe &lt; 3) {" line148="            Lampen.setPixelColor(lampe, color)" line149="            if (color != 0x000000) {" line150="                lampen_state[lampe] = true;" line151="            } else {" line152="                lampen_state[lampe] = false;" line153="            }" line154="        } else { // Wandlampe" line155="            wl.showColor(color)" line156="            if (color != 0x000000) {" line157="                lampen_state[3] = true;" line158="            } else {" line159="                lampen_state[3] = false;" line160="            }" line161="        }" line162="        Lampen.show()" line163="    }" line164="" line165="    /**" line166="    * Schalte eine Lampe aus" line167="    */" line168="    //% block=&quot;switch $lampe off&quot;" line169="    //% block.loc.de=&quot;schalte $lampe aus&quot;" line170="    //% inlineInputMode=inline" line171="    export function SwitchLampOff(lampe: lampennamen = lampennamen.dl1) {" line172="        if (lampe &lt; 3) {" line173="            Lampen.setPixelColor(lampe, 0x000000)" line174="        } else { // Wandlampe" line175="            wl.showColor(0x000000)" line176="        }" line177="        lampen_state[lampe] = false;" line178="        Lampen.show()" line179="    }" line180="" line181="    /**" line182="    * Gibt den Status einer Lampe zurück" line183="    */" line184="    //% block=&quot;$lampe is on&quot;" line185="    //% block.loc.de=&quot;$lampe ist an&quot;" line186="    //% inlineInputMode=inline" line187="    //% weight=5" line188="    //% group=&quot;Zustände&quot;" line189="    export function GetLampStatus(lampe: lampennamen = lampennamen.dl1) : boolean {" line190="        return lampen_state[lampe];" line191="    }" line192="" line193="    /**" line194="    * Custom color picker" line195="    */" line196="    //% blockId=LampenColorNumberPicker block=&quot;%value&quot;" line197="    //% blockHidden=true" line198="    //% shim=TD_ID" line199="    //% value.fieldEditor=&quot;colornumber&quot; value.fieldOptions.decompileLiterals=true" line200="    //% weight=150" line201="    //% value.fieldOptions.colours='[&quot;#ffffff&quot;,&quot;#ff0000&quot;,&quot;#ffaa00&quot;,&quot;#ffdc00&quot;,&quot;#ffff00&quot;,&quot;#eaff00&quot;,&quot;#8eff00&quot;,&quot;#4df243&quot;,&quot;#42b87f&quot;,&quot;#00ffdc&quot;,&quot;#00dcff&quot;,&quot;#00a3ff&quot;,&quot;#0087ff&quot;,&quot;#acb3f3&quot;,&quot;#e0acfe&quot;,&quot;#a300ff&quot;,&quot;#ea00ff&quot;,&quot;#ff00e3&quot;,&quot;#fdd3f8&quot;,&quot;#f1d07e&quot;,&quot;#a8b5f5&quot;,&quot;#C3C6D8&quot;, &quot;#f3f2da&quot;,&quot;#727474&quot;, &quot;#000000&quot;]'" line202="    //% value.fieldOptions.columns=5 value.fieldOptions.className='rgbColorPicker'  " line203="    export function CalliColorNumberPicker(value: number) {" line204="        return value;" line205="    }" line206="" line207="    /**" line208="     * Code für die Touch Schalter" line209="     * based on https://github.com/mkleinsb/pxt-mpr121 by Michael Klein" line210="     * mpr 121 touch blocks based on touch.ts 0.17.5" line211="     * Auf Basis von https://github.com/1010Technologies/pxt-makerbit" line212="     * Copyright (c) 2018 Roger Wagner, Philipp Henkel &amp; Michael Klein" line213="     * MIT License" line214="     */" line215="" line216="    const MPR121_ADDRESS = 0x5A" line217="    const TOUCH_STATUS_PAUSE_BETWEEN_READ = 50" line218="" line219="    interface TouchController {" line220="        lastTouchStatus: number" line221="        lastEventValue: number" line222="    }" line223="" line224="    let touchController: TouchController" line225="" line226="    const MPR121_TOUCH_SENSOR_TOUCHED_ID = 2148" line227="    const MPR121_TOUCH_SENSOR_RELEASED_ID = 2149" line228="" line229="" line230="    /**" line231="     * Initialize the touch controller." line232="     */" line233="" line234="    //% blockId=&quot;mpr121_touch_init&quot; block=&quot;initialisiere touch-Sensor&quot;" line235="    //% weight=70" line236="    function initTouchController(): void {" line237="" line238="        if (!!touchController) {" line239="            return" line240="        }" line241="" line242="        touchController = {" line243="            lastTouchStatus: 0," line244="            lastEventValue: 0," line245="        }" line246="" line247="        const addr = MPR121_ADDRESS" line248="        mpr121.reset(addr)" line249="" line250="        // Stop capture" line251="        mpr121.stop(addr)" line252="" line253="        // Input filter for rising state" line254="        mpr121.configure(addr, mpr121.Config.MHDR, 0x01)" line255="        mpr121.configure(addr, mpr121.Config.NHDR, 0x01)" line256="        mpr121.configure(addr, mpr121.Config.NCLR, 0x10)" line257="        mpr121.configure(addr, mpr121.Config.FDLR, 0x20)" line258="" line259="        // Input filter for falling state" line260="        mpr121.configure(addr, mpr121.Config.MHDF, 0x01)" line261="        mpr121.configure(addr, mpr121.Config.NHDF, 0x01)" line262="        mpr121.configure(addr, mpr121.Config.NCLF, 0x10)" line263="        mpr121.configure(addr, mpr121.Config.FDLF, 0x20)" line264="" line265="        // Input filter for touched state" line266="        mpr121.configure(addr, mpr121.Config.NHDT, 0x01)" line267="        mpr121.configure(addr, mpr121.Config.NCLT, 0x10)" line268="        mpr121.configure(addr, mpr121.Config.FDLT, 0xFF)" line269="" line270="        // Unused proximity sensor filter" line271="        mpr121.configure(addr, mpr121.Config.MHDPROXR, 0x0F)" line272="        mpr121.configure(addr, mpr121.Config.NHDPROXR, 0x0F)" line273="        mpr121.configure(addr, mpr121.Config.NCLPROXR, 0x00)" line274="        mpr121.configure(addr, mpr121.Config.FDLPROXR, 0x00)" line275="        mpr121.configure(addr, mpr121.Config.MHDPROXF, 0x01)" line276="        mpr121.configure(addr, mpr121.Config.NHDPROXF, 0x01)" line277="        mpr121.configure(addr, mpr121.Config.NCLPROXF, 0xFF)" line278="        mpr121.configure(addr, mpr121.Config.FDLPROXF, 0xFF)" line279="        mpr121.configure(addr, mpr121.Config.NHDPROXT, 0x00)" line280="        mpr121.configure(addr, mpr121.Config.NCLPROXT, 0x00)" line281="        mpr121.configure(addr, mpr121.Config.FDLPROXT, 0x00)" line282="" line283="        // Debounce configuration (used primarily for interrupts)" line284="        mpr121.configure(addr, mpr121.Config.DTR, 0x11)" line285="" line286="        // Electrode clock frequency etc" line287="        mpr121.configure(addr, mpr121.Config.AFE1, 0xFF)" line288="        mpr121.configure(addr, mpr121.Config.AFE2, 0x30)" line289="" line290="        // Enable autoconfiguration / calibration" line291="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_0, 0x00)" line292="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_1, 0x00)" line293="" line294="        // Tuning parameters for the autocalibration algorithm" line295="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_USL, 0x00)" line296="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_LSL, 0x00)" line297="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_TL, 0x00)" line298="" line299="        // Default sensitivity thresholds" line300="        mpr121.configureThresholds(addr, 60, 20)" line301="" line302="        // Restart capture" line303="        mpr121.start(" line304="            addr," line305="            mpr121.CalibrationLock.BaselineTrackingAndInitialize," line306="            mpr121.Proximity.DISABLED," line307="            mpr121.Touch.ELE_0_TO_11" line308="        )" line309="        control.inBackground(detectAndNotifyTouchEvents)" line310="    }" line311="" line312="    function detectAndNotifyTouchEvents() {" line313="        let previousTouchStatus = 0" line314="" line315="        while (true) {" line316="            const touchStatus = mpr121.readTouchStatus(MPR121_ADDRESS)" line317="            touchController.lastTouchStatus = touchStatus" line318="" line319="            for (let touchSensorBit = 1; touchSensorBit &lt;= 2048; touchSensorBit &lt;&lt;= 1) {" line320="" line321="                // Raise event when touch starts" line322="                if ((touchSensorBit &amp; touchStatus) !== 0) {" line323="                    if (!((touchSensorBit &amp; previousTouchStatus) !== 0)) {" line324="                        control.raiseEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, touchSensorBit)" line325="                        touchController.lastEventValue = touchSensorBit" line326="                    }" line327="                }" line328="" line329="                // Raise event when touch ends" line330="                if ((touchSensorBit &amp; touchStatus) === 0) {" line331="                    if (!((touchSensorBit &amp; previousTouchStatus) === 0)) {" line332="                        control.raiseEvent(MPR121_TOUCH_SENSOR_RELEASED_ID, touchSensorBit)" line333="                        touchController.lastEventValue = touchSensorBit" line334="                    }" line335="                }" line336="            }" line337="" line338="            previousTouchStatus = touchStatus" line339="" line340="            basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line341="        }" line342="    }" line343="" line344="    /**" line345="     * Mache etwas, wenn ein spezieller Sensor berührt wird." line346="     * Dieses Touch-Ereignis wird direkt zu Beginn der Berührung ausgeführt." line347="     * @param sensor der Touchsensor der überwacht werden soll, z.B.: TouchSensor.T0" line348="     * @param handler body code der bei der Berührung des Sensors ausgeführt werden soll" line349="    */" line350="" line351="    //% blockId=mpr121_touch_on_touch_sensor_down" line352="    //% block=&quot;wenn Schalter | %sensor | gedrückt&quot;" line353="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=3" line354="    //% sensor.fieldOptions.tooltips=&quot;false&quot;" line355="    //% weight=65" line356="    export function onTouchSensorTouched(sensor: TouchSensor, handler: () =&gt; void) {" line357="        initTouchController()" line358="        control.onEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, sensor, () =&gt; {" line359="            setupContextAndNotify(handler)" line360="        })" line361="    }" line362="" line363="    function setupContextAndNotify(handler: () =&gt; void) {" line364="        touchController.lastEventValue = control.eventValue()" line365="        handler()" line366="    }" line367="" line368="    // Communication module for MPR121 capacitive touch sensor controller" line369="    // https://www.sparkfun.com/datasheets/Components/MPR121.pdf" line370="    export namespace mpr121 {" line371="" line372="        export enum CalibrationLock {" line373="            BaselineTrackingOn = 0b00," line374="            BaselineTrackingOff = 0b01," line375="            BaselineTrackingAndInitializeFirst5MSB = 0b10," line376="            BaselineTrackingAndInitialize = 0b11" line377="        }" line378="" line379="        export enum Proximity {" line380="            DISABLED = 0b00," line381="            ELE0_TO_1 = 0b01," line382="            ELE_0_TO_3 = 0b10," line383="            ELE_0_TO_11 = 0b11" line384="        }" line385="" line386="        export enum Touch {" line387="            DISABLED = 0b0000," line388="            ELE_0 = 0b0001," line389="            ELE_0_TO_1 = 0b0010," line390="            ELE_0_TO_2 = 0b0011," line391="            ELE_0_TO_3 = 0b0100," line392="            ELE_0_TO_4 = 0b0101," line393="            ELE_0_TO_5 = 0b0110," line394="            ELE_0_TO_6 = 0b0111," line395="            ELE_0_TO_7 = 0b1000," line396="            ELE_0_TO_8 = 0b1001," line397="            ELE_0_TO_9 = 0b1010," line398="            ELE_0_TO_10 = 0b1011," line399="            ELE_0_TO_11 = 0b1100" line400="        }" line401="" line402="        export enum Config {" line403="            MHDR = 0x2B," line404="            NHDR = 0x2C," line405="            NCLR = 0x2D," line406="            FDLR = 0x2E," line407="            MHDF = 0x2F," line408="            NHDF = 0x30," line409="            NCLF = 0x31," line410="            FDLF = 0x32," line411="            NHDT = 0x33," line412="            NCLT = 0x34," line413="            FDLT = 0x35," line414="            MHDPROXR = 0x36," line415="            NHDPROXR = 0x37," line416="            NCLPROXR = 0x38," line417="            FDLPROXR = 0x39," line418="            MHDPROXF = 0x3A," line419="            NHDPROXF = 0x3B," line420="            NCLPROXF = 0x3C," line421="            FDLPROXF = 0x3D," line422="            NHDPROXT = 0x3E," line423="            NCLPROXT = 0x3F," line424="            FDLPROXT = 0x40," line425="            E0TTH = 0x41," line426="            E0RTH = 0x42," line427="            E1TTH = 0x43," line428="            E1RTH = 0x44," line429="            E2TTH = 0x45," line430="            E2RTH = 0x46," line431="            E3TTH = 0x47," line432="            E3RTH = 0x48," line433="            E4TTH = 0x49," line434="            E4RTH = 0x4A," line435="            E5TTH = 0x4B," line436="            E5RTH = 0x4C," line437="            E6TTH = 0x4D," line438="            E6RTH = 0x4E," line439="            E7TTH = 0x4F," line440="            E7RTH = 0x50," line441="            E8TTH = 0x51," line442="            E8RTH = 0x52," line443="            E9TTH = 0x53," line444="            E9RTH = 0x54," line445="            E10TTH = 0x55," line446="            E10RTH = 0x56," line447="            E11TTH = 0x57," line448="            E11RTH = 0x58," line449="            E12TTH = 0x59," line450="            E12RTH = 0x5A," line451="            DTR = 0x5B," line452="            AFE1 = 0x5C," line453="            AFE2 = 0x5D," line454="            ECR = 0x5E," line455="            CDC0 = 0x5F," line456="            CDC1 = 0x60," line457="            CDC2 = 0x62," line458="            CDC4 = 0x63," line459="            CDC5 = 0x64," line460="            CDC6 = 0x65," line461="            CDC7 = 0x66," line462="            CDC8 = 0x67," line463="            CDC9 = 0x68," line464="            CDC10 = 0x69," line465="            CDC11 = 0x6A," line466="            CDC12 = 0x6B," line467="            CDT_0_1 = 0x6C," line468="            CDT_2_3 = 0x6D," line469="            CDT_4_5 = 0x6E," line470="            CDT_6_7 = 0x6F," line471="            CDT_8_9 = 0x70," line472="            CDT_10_11 = 0x71," line473="            CDT_12 = 0x72," line474="            GPIO_CTL0 = 0x73," line475="            GPIO_CTL1 = 0x74," line476="            GPIO_DIR = 0x76," line477="            GPIO_EN = 0x77," line478="            GPIO_SET = 0x78," line479="            GPIO_CLR = 0x79," line480="            GPIO_TOG = 0x7A," line481="            AUTO_CONFIG_0 = 0x7B," line482="            AUTO_CONFIG_1 = 0x7C," line483="            AUTO_CONFIG_USL = 0x7D," line484="            AUTO_CONFIG_LSL = 0x7E," line485="            AUTO_CONFIG_TL = 0x7F" line486="        }" line487="" line488="        let commandDataBuffer: Buffer" line489="        let commandBuffer: Buffer" line490="" line491="        function writeCommandData(address: number, command: number, data: number): void {" line492="            if (!commandDataBuffer) {" line493="                commandDataBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt16BE))" line494="            }" line495="            commandDataBuffer.setNumber(NumberFormat.UInt16BE, 0, (command &lt;&lt; 8) | data)" line496="            pins.i2cWriteBuffer(address, commandDataBuffer)" line497="        }" line498="" line499="        function writeCommand(address: number, command: number): void {" line500="            if (!commandBuffer) {" line501="                commandBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt8BE))" line502="            }" line503="            commandBuffer.setNumber(NumberFormat.UInt8BE, 0, command)" line504="            pins.i2cWriteBuffer(address, commandBuffer)" line505="        }" line506="" line507="        export function configure(address: number, register: Config, value: number): void {" line508="            writeCommandData(address, register, value)" line509="        }" line510="" line511="        export function configureThresholds(address: number, touch: number, release: number): void {" line512="            for (let k = 0; k &lt; 12; k++) {" line513="                configure(address, Config.E0TTH + k * 2, touch)" line514="                configure(address, Config.E0RTH + k * 2, release)" line515="            }" line516="        }" line517="" line518="        export function reset(address: number): void {" line519="            writeCommandData(address, 0x80, 0x63)" line520="            basic.pause(30)" line521="        }" line522="" line523="        export function stop(address: number): void {" line524="            writeCommandData(address, Config.ECR, 0x0)" line525="        }" line526="" line527="        export function start(address: number, cl: CalibrationLock, eleprox: Proximity, ele: Touch): void {" line528="            writeCommandData(address, Config.ECR, (cl &lt;&lt; 6) | (eleprox &lt;&lt; 4) | ele)" line529="        }" line530="" line531="        export function readTouchStatus(address: number): number {" line532="            writeCommand(address, 0x0)" line533="            return pins.i2cReadNumber(address, NumberFormat.UInt16LE)" line534="        }" line535="    }" line536="" line537="    /**" line538="     * Code for the presence controller. (old and new Version, IR and ToF)" line539="     * by Moritz Metelmann" line540="     */" line541="" line542="    interface PresenceDetector {" line543="        lastPresenceDetection: boolean" line544="    }" line545="" line546="    let presenceDetector: PresenceDetector" line547="    const PRESENCE_DETECTED_ID = 2147" line548="" line549="    /**" line550="     * Initialize the presence controller." line551="     */" line552="" line553="    //% blockId=&quot;presence_init&quot; block=&quot;initialisiere Präsenz-Sensor&quot;" line554="    //% weight=70" line555="    function initPresenceDetector(): void {" line556="" line557="        if (!!presenceDetector) {" line558="            return" line559="        }" line560="" line561="        presenceDetector = {" line562="            lastPresenceDetection: false" line563="        }" line564="" line565="        Rangefinder.init();" line566="" line567="        control.inBackground(detectAndNotifyPresenceDetector)" line568="    }" line569="" line570="    function detectAndNotifyPresenceDetector() {" line571="        let previousPresenceStatus = false;" line572="" line573="        while (true) {" line574="            if (previousPresenceStatus == false &amp;&amp; (pins.digitalReadPin(DigitalPin.C9) == 0 || Rangefinder.distance() &lt; 80)) {" line575="                control.raiseEvent(PRESENCE_DETECTED_ID, 0);" line576="                previousPresenceStatus = true;" line577="            }" line578="            if (previousPresenceStatus == true &amp;&amp; (pins.digitalReadPin(DigitalPin.C9) == 1 &amp;&amp; (Rangefinder.distance() &gt;= 80 || Rangefinder.distance() == 0 ))) {" line579="                previousPresenceStatus = false;" line580="                basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line581="            }" line582="" line583="            " line584="        }" line585="" line586="" line587="    }" line588="" line589="    //% blockId=smarthome_presence_detected" line590="    //% block=&quot;wenn Präsenz gemeldet&quot;" line591="    //% weight=65" line592="    export function onPresenceDetected(handler: () =&gt; void) {" line593="        initPresenceDetector();" line594="        control.onEvent(PRESENCE_DETECTED_ID, EventBusValue.MICROBIT_EVT_ANY, () =&gt; {" line595="            handler();" line596="        })" line597="    }" line598="}" numlines="599"></mutation></block></next></block></next></block></next></block></next></block></statement></block><block type="device_forever" id="jqh`0O]s1n{S7_EX_,/P" x="2861" y="0"></block></xml>